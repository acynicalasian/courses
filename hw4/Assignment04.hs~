module Assignment04 where

import Prelude hiding (Either(..))

import Control.Applicative(liftA, liftA2, liftA3)
import Data.List(nub)

import FiniteStatePart2

---------------------------------------
-- Setup for section 1

type SLG sy = ([sy], [sy], [sy], [(sy,sy)])
data ConstructedState sy = ExtraState | StateForSymbol sy deriving (Eq, Show)

slg1 :: SLG SegmentCV
slg1 = ([C,V], [C], [V], [(C,C),(C,V),(V,V)])

slg2 :: SLG Int
slg2 = ([1,2,3], [1,2,3], [1,2,3], [(1,1),(2,2),(3,3),(1,2),(2,1),(1,3),(3,1)])

---------------------------------------
-- Setup for section 2

data Either a b = First a | Second b deriving (Show,Eq)

re1 :: RegExp Char
re1 = Concat (Alt (Lit 'a') (Lit 'b')) (Lit 'c')

re2 :: RegExp Char
re2 = Star re1

re3 :: RegExp Int
re3 = Star (Concat ZeroRE (Lit 3)) 

re4 :: RegExp Int
re4 = Concat (Alt (Lit 0) (Lit 1)) (Star (Lit 2))

------------------------------------------------------------------
------------------------------------------------------------------
-- IMPORTANT: Please do not change anything above here.
--            Write all your code below this line.

generatesSLG :: (Eq sy) => SLG sy -> [sy] -> Bool
generatesSLG slg str = let (alpha, i, f, pair) = slg in
                         case str of
                           [] -> False
                           x : [] -> elem x i && elem x f
                           x : sub -> elem x i && (case sub of
                                                     y : [] -> elem y f && elem (x, y) pair
                                                     y : z -> elem (x, y) pair && helper_1A slg (y : z)
                                                  )

helper_1A :: (Eq sy) => SLG sy -> [sy] -> Bool
helper_1A slg str = let (alpha, i, f, pair) = slg in
                      case str of
                        x : sub -> case sub of
                                     y : [] -> elem y f && elem (x, y) pair
                                     y : z -> elem (x, y) pair && helper_1A slg (y : z)


-- Helpers for slgToFSA
sy_checkPair :: (Eq sy) => sy -> [(sy, sy)] -> [(ConstructedState sy, sy, ConstructedState sy)]
sy_checkPair sym pair =
  case pair of
    [] -> []
    x : rest ->
      let (sy1, sy2) = x in
        case (sym == sy1) of
          True -> (StateForSymbol sym, sy2, StateForSymbol sy2) : sy_checkPair sym rest
          False -> sy_checkPair sym rest

sy_allCheck :: (Eq sy) => [sy] -> [(sy, sy)] -> [(ConstructedState sy, sy, ConstructedState sy)]
sy_allCheck sym pair =
  case sym of
    [] -> []
    x : rest ->
      (sy_checkPair x pair) ++ (sy_allCheck rest pair)


slgToFSA :: (Eq sy) => SLG sy -> Automaton (ConstructedState sy) sy
slgToFSA slg  = let (slg_alpha, slg_i, slg_f, slg_pair) = slg in
  let
    auto_states = [ExtraState] ++ map StateForSymbol slg_alpha
    auto_alpha = slg_alpha
    auto_i = [ExtraState]
    auto_f = map StateForSymbol slg_f
    auto_trans = map (\sym -> (ExtraState, sym, StateForSymbol sym)) slg_i ++ sy_allCheck slg_alpha slg_pair
  in
    (auto_states, auto_alpha, auto_i, auto_f, auto_trans)

